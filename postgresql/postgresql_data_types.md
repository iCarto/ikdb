# Tipos de Datos en PostgreSQL

PostgreSQL es increíblemente versátil en cuanto a [tipos de datos](https://www.postgresql.org/docs/current/datatype.html), permitiendo al usuario crear nuevos tipos ([CREATE TYPE](https://www.postgresql.org/docs/current/sql-createtype.html) Y [CREATE DOMAIN](https://www.postgresql.org/docs/current/sql-createdomain.html) y añadiendo más mediante extensiones.

En esta guía explicamos la lógica que seguimos en iCarto a la hora de usar algunos tipos de datos para reducir la fatiga mental de tomar decisiones mediante _defaults_ sanos para muchos casos.

## Resumen

-   Autoincrementales: `int GENERATED BY DEFAULT AS IDENTITY`
-   Autoincrementales versiones antiguas: `serial`,
-   Decimales: `numeric[10, 2]`, `numeric[12, 4]`
-   Enteros: `int`
-   Textos
-   Tiempo: `date`, `time without time zone` y `timestamp without time zone`
-   JSON: `jsonb`
-   Booleanos: `boolean NOT NULL DEFAULT FALSE`

## Autoincrementales

-   Opciones:
    -   `int GENERATED BY DEFAULT AS IDENTITY`
    -   `serial`
-   Nuestra opción por defecto: `int GENERATED BY DEFAULT AS IDENTITY`

Ver 'database_design_primary_key.md'.

## Números con decimales

-   Opciones:
    -   `double precision` y sus alias: `float`, `float8`
    -   `numeric` y sus alias: `decimal`
    -   `real` y sus alias `float4`
-   Nuestra opción por defecto: `numeric[10, 2]`, `numeric[12, 4]`

Tomamos esta decisión en su momento porqué en la mayoría de nuestras aplicaciones tenía sentido realizar cálculos con dos decimales y nos evitaba pequeños problemas. En algunos casos por ejemplo cuando se usan unidades de medida como hectáreas o metros cúbicos una precisión de cuatro decimales suele ser aconsejable.

Las penalizaciones de rendimiento y consumo de recursos por usar un tipo u otro no son tan simples como decir que `numeric` es más lento que `float` o `integer`. Lo es en general pero no en todas las situaciones. El mayor problema está en escritura pero [según esta comparativa](https://www.depesz.com/2014/12/06/how-much-slower-are-numerics/) insertar un millón de filas (sin índice) pueden ser 0.3s de diferencia. Y con índice 1s.

Empleamos `float` cuando es necesario rapidez de cálculos o almacenar un número grande, indeterminado de decimales.

## Números enteros

-   Opciones:

    -   `bigint` y sus alias: `int8`
    -   `smallint` y sus alias: `int2`
    -   `integer` y sus alias: `int`, `int4`

-   Nuestra opción por defecto: `integer`

## Textos

-   Opciones:
    -   `character varying(n)` y sus alias: `varchar(n)`. Especificar `n` es opcional.
    -   `character(n)` y sus alias `char(n)`
    -   `text`
-   Nuestra opción por defecto: `text`

Las razones [está bien explicadas en la wiki de PostgreSQL](https://wiki.postgresql.org/wiki/Don't_Do_This#Text_storage). Como resumen:

-   Nunca se debería usar `char`. Da demasiados problemas.
-   `varchar` (sin límite) y `text` son en esencia lo mismo, pero `text` como _término_ refleja mejor la intención.
-   [No hay diferencias serias](https://www.depesz.com/2010/03/02/charx-vs-varcharx-vs-varchar-vs-text/) de consumo de recursos o rendimiento entre `varchar`, `varchar(n)` y `text`.

Si hay que limitar por lógica de negocio el número de caracteres de un campo habitualmente esto debería venir acompañado de otro tipo de validación (por ejemplo que un _id_ cumpla un determinado formato). Para ello se pueden usar `TRIGGER`, `CONSTRAINT`, o `DOMAIN`. Es un poco más de trabajo pero también más fiable.

### Limitar el tamaño de los campos por seguridad

Permitir campos de texto de tamaño indefinido tiene el problema de que alguien podría atacar o abusar del sistema subiendo enormes cantidades de texto en un campo. Tener un límite elevado `varchar(10000)` por defecto puede ser una forma de protegerse de un problema así.

Esta es una técnica interesante pero que no llega por si sola, en lugar de una fila con 5GB de texto, pueden crearse 100 filas de 50MB. Y no será un problema en la mayoría de aplicaciones corporativas.

Así que esta técnica será una YAGNI en la mayoría de casos.

> Put a limit on everything. Everything that can happen repeatedly put a high limit on it and raise or lower the limit as needed. Block users if the limit is passed. This protects the service. Example is uploading files of logos for subreddits. Users figured out they could upload really big files and harm the system. Don’t accept huge text blobs either. Someone will figure out how to send you 5GB of text.
> http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html

Brandur nos presenta [una opinión ligeramente distinta](https://brandur.org/text) dado los problemas que puede generar no limitar el número de caracteres que en resumen sería:

-   `varchar(200)` for shorter-length strings like names, addresses, email addresses, etc.
-   `varchar(2000)` for longer text blocks like descriptions.
-   `varchar(20000)` for really long text blocks.

### Ejemplos

```sql
create table test_varchar(id serial primary key, v varchar(6));

insert into test_varchar (v) values (1234567);
> ERROR:  22001: value too long for type character varying(6)

insert into test_varchar (v) values ('1234567');
> ERROR:  22001: value too long for type character varying(6)

insert into test_varchar (v) values (1234567::varchar);
> ERROR:  22001: value too long for type character varying(6)

insert into test_varchar (v) values ('1234567'::varchar);
> ERROR:  22001: value too long for type character varying(6)

-- los trailing spaces son truncados automáticamente cuando pasan del límite
insert into test_varchar (v) values ('123456 '::varchar);
> INSERT 0 1
```

## Fechas, Horas y Timestamps

-   Opciones: `date`, `time without time zone`, `time with time zone` (alias `timetz`), `timestamp without time zone`, `timestamp with time zone` (alias `timestamptz`), `interval`

Sobre como gestionar datos de tiempo en una aplicación hace falta escribir un libro entero.

En contra de la norma nosotros hemos optado por defecto por usar `date`, `time without time zone` y `timestamp without time zone`, con ajustes de como gestionar las fechas fuera de PostgreSQL.

## JSON

-   Opciones: `json`, `jsonb`
-   Nuestra opción por defecto: `jsonb`

Sólo tiene sentido usar `json` cuando haya que mantener el orden de inserción de las claves.

Tanto SQLAlchemy con Django ORM tienen buen soporte haciendo conversión a diccionarios de python. Los GIS de Escritorio lo interpretan como un campo de texto, por lo que debe usarse sin proporcionar _widgets_ específicos.

## Booleanos

-   Nuestra opción por defecto: `boolean NOT NULL DEFAULT FALSE`
-   [Más información](http://conocimientoabierto.es/modelado-de-datos-booleanos-en-la-base-de-datos/891/)
-   A pesar de que hay formas visuales de generar checkboxes tri-estados, en general es confuso y sólo debería usarse para el caso de árboles de checkboxes anidados. [1](https://css-tricks.com/indeterminate-checkboxes/) [2](https://vanderlee.github.io/tristate/)
-   La opción preferida de nombrar los valores es: `TRUE` y `FALSE`

## Curiosidades y otras observaciones

-   A la hora de escoger un alias para definir el tipo preferimos los que sean acordes al estándar y [que se lleven bien con SQLite](https://www.sqlite.org/datatype3.html#affinity_name_examples).
-   Los tipos de datos se escriben en minúsculas. En general el estilo en cuanto a capitalización para SQL es seguir el que se use en los ejemplos de PostgreSQL dando preferencia al que se pueda automatizar con [pgFormatter](https://github.com/darold/pgFormatter)
-   Cuando creamos una nueva base de datos siempre forzamos el encoding: `UTF8` y el locale (según corresponda). `createdb -E UTF8 -l es_ES.utf8 ...`

### Alineamiento de datos

Reordenando las columnas dentro de una tabla en función de los bytes que ocupa en disco es posible reducir el tamaño de las filas. Una práctica que sólo tiene sentido cuando hay muchas filas y se busca micro-optimizar.

-   https://postgresrocks.enterprisedb.com/t5/Postgres-Gems/Data-Alignment-in-PostgreSQL/ba-p/2113
-   https://www.cybertec-postgresql.com/en/shrinking-the-storage-footprint-of-data/

### Tipos Enumerados

En general huimos de [enum](https://tapoueh.org/blog/2018/05/postgresql-data-types-enum/). Sólo suele ser útil para mantener "estados internos" que no se expongan al cliente. En caso contrario por ejemplo un campo que se presenta en la interfaz como un combobox usamos una "tabla de dominios" (¿lookup table?) con claves foráneas, lo que permite "subir" los posibles valores al cliente de forma sencilla (y añadir información extra al dominio)

### XML

De raro uso en la actualidad. Según el caso se puede usar `xml` o `text` según el caso.

### Blobs y datos binarios

En ocasiones interesa almacenar imágenes, ficheros o [strings binarios](https://www.postgresql.org/docs/9.1/datatype-binary.html) en la base de datos. Para estos casos se usa `bytea`. PostgreSQL no soporta el estándar `blob` pero [bytea es en esencia lo mismo](http://www.postgresqltutorial.com/postgresql-python/blob/).

La discusión sobre si se deben almacenar o no binarios en una base de datos es eterna. La situación típica donde esto tiene ventajas es una aplicación de inventario con GIS de escritorio donde se permita almacenar alguna (pocas) imágenes de los elementos inventariados. Para evitar la necesidad de un servidor de ficheros se pueden almacenar las imágenes directamente en la base de datos.

-   https://stackoverflow.com/questions/4386030/how-to-use-blob-datatype-in-postgres
-   https://www.postgresql.org/docs/current/largeobjects.html
-   https://wiki.postgresql.org/wiki/BinaryFilesInDB

## Referencias

-   https://wiki.postgresql.org/wiki/Don't_Do_This
-   https://tapoueh.org/tags/data-types/
-   https://www.postgresql.org/docs/current/datatype.html
-   https://www.guru99.com/postgresql-data-types.html

## Investigaciones y mejoras futuras

-   Si debemos usar tipos con `time zone` o sin él, es algo que debemos trabajar un poco más.

-   Describir los casos en los que usar `interval`

-   Describir los casos de uso para FTS. Probablemente en documento aparte junto a unnacent, trigrams, ...

-   Describir (probablemente en documento aparte) la implementación de lógica de negocio y validaciones en postgres. `CHECK`, `TRIGGER`, `DOMAIN`, ...

-   Los tipos de [rangos](https://www.postgresql.org/docs/current/rangetypes.html) son una funcionalidad super-útil. No es algo que se vaya a utilizar todos los días pero ahorran un montón de código cuando son la herramienta adecuada. Proporcionar ejemplos de cuando usarlos y porqué:

    -   https://tapoueh.org/blog/2018/04/postgresql-data-types-ranges/
    -   https://wiki.postgresql.org/images/7/73/Range-types-pgopen-2012.pdf

-   Geometrías. Requiere una sección aparte pero como norma general se usara `geometry (MultiXX, SRID)`. No se usará `Z`, ni `M`, y se usarán las versiones Multi por compatibilidad con aplicaciones GIS de escritorio antiguos.

*   Al igual que los rangos, hay algunas situaciones en las que un array encaja muy bien. Un caso típico de uso es una lista de checkboxes relacionados (municipios, ...) o asignar etiquetas. Casos donde usar una tabla de relación puede ser un _overkill_.

    -   https://www.postgresql.org/docs/current/arrays.html
    -   https://tapoueh.org/blog/2018/04/postgresql-data-types-arrays/

*   Elaborando este documento hemos revisado el uso de `numeric` tratando de mostrar algunos de los problemas de usar `float`. Lo cierto es que esta decisión es en este momento revisable:
    -   https://stackoverflow.com/questions/42526681/how-to-avoid-floating-point-error-calculate-average-value-in-postgres-db-and-get

```sql
create table foo (id serial primary key, f float8, n numeric(10,3));
insert into foo (f, n) values (1.001,1.001), (1.021, 1.021), (2.022, 2.022);
insert into foo (f, n) values ('1.001','1.001'), ('1.021', '1.021'), ('2.022', '2.022');

select * from foo;
select 0.1::float8 + 0.2::float8;
select 3.33::float8;

\set extra_float_digits 5

select * from foo;
select 0.1::float8 + 0.2::float8;
select 3.33::float8;
```

```python
import psycopg2
con = psycopg2.connect("host=localhost port=5432 dbname=test user=postgres")
cur = con.cursor()
cur.execute('SELECT * FROM foo;')
for r in cur: print(r)
cur.execute('SELECT 1.0::float8 + 2.0::float8;')
for r in cur: print(r)
```

```java
package javaproject;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Test {

    private static void createTable(Connection c) throws SQLException {
        Statement stmt = null;
        stmt = c.createStatement();
        String sql = "create table if not exists bar (id serial primary key, f float8, n numeric(10,3));";
        stmt.executeUpdate(sql);
        stmt.close();
    }

    public static void insertInto(Connection c) throws SQLException {
        Statement stmt = null;
        stmt = c.createStatement();
        String sql = "DELETE from bar;";
        stmt.executeUpdate(sql);
        stmt = c.createStatement();
        sql = "insert into bar (f, n) values (1.001,1.001), (1.021, 1.021), (2.022, 2.022);";
        stmt.executeUpdate(sql);
        sql = "insert into bar (f, n) values ('1.001','1.001'), ('1.021', '1.021'), ('2.022', '2.022');";
        stmt.executeUpdate(sql);
        stmt.close();
    }

    public static void selectFrom(Connection c) throws SQLException {
        Statement stmt = null;
        stmt = c.createStatement();
        ResultSet rs = stmt.executeQuery( "SELECT * FROM bar;" );
        while ( rs.next() ) {
            double f = rs.getDouble("f");
            BigDecimal n = rs.getBigDecimal("n");
            System.out.println(f);
            System.out.println(n);
        }
        rs.close();
        stmt.close();
    }

    public static void main(String args[]) {
        Connection c = null;
        try {
           Class.forName("org.postgresql.Driver");
           c = DriverManager
              .getConnection("jdbc:postgresql://localhost:5432/test",
              "postgres", "postgres");
           createTable(c);
           insertInto(c);
           selectFrom(c);
        } catch (Exception e) {
           e.printStackTrace();
           System.exit(0);
        }
     }

}
```
