# Claves primarias Auto Incrementales

En iCarto empezamos a trabajar con PostgreSQL de la mano de las aplicaciones GIS de Escritorio. En aquel momento para que la aplicación se comportara correctamente era necesario que la clave primaria fuera un entero y en ocasiones hasta era obligatorio (o muy preferible usar `gid`) como nombre. De ahí que en su momento adoptaramos y mantuvieramos el uso de claves primarias autoincrementales en todos nuestras tablas o al menos en todas aquellas susceptibles de ser cargadas en una aplicación GIS de escritorio.

En PostgreSQL >= 10.2, [por un bug](https://dba.stackexchange.com/a/200156/15606), la forma preferida de hacer esto es mediante [Identity Columns](https://www.depesz.com/2017/04/10/waiting-for-postgresql-10-identity-columns/). En versiones anteriores mediante [Serial](https://severalnines.com/blog/overview-serial-pseudo-datatype-postgresql)



## Identity Columns

Las declaramos así

```sql
CREATE TABLE public.mytable (
    gid int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY 
    , foo TEXT
);

/* En caso de ser necesario se pueden setear `sequence options` directamente
   en create table */

CREATE TABLE public.mytable (
    gid int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (
        START WITH 3 INCREMENT BY 2
    )
    , foo TEXT
);

REVOKE ALL ON public.mytable FROM PUBLIC;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.mytable TO role_edit;
GRANT SELECT ON public.mytable TO role_view;
```

_**Nota**: Los permisos se añaden a modo de ejemplo para entender una de las diferencias entre Identity y Serial_

Preferimos el uso de Indentity Columns por varios motivos:

* [Clonar la tabla es más sencillo](https://stackoverflow.com/questions/12264719/)
* [No es necesario gestionar los permisos de la secuencia por separado](https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns/). En general las "manipulaciones" son más sencillas y seguras.
* Es más conforme al estándar SQL


### Observaciones

* La manipulación de la secuencia implícita ahora se hace a través de manipular la propia columna. La sintaxis puede ser un poco extraña, se adjuntan ejemplos, siendo la forma preferida en icarto la primera

```sql
ALTER TABLE foo ALTER COLUMN gid SET START WITH 600 SET INCREMENT BY 7;
ALTER TABLE foo ALTER COLUMN gid SET MAXVALUE 10000 SET INCREMENT BY 7 SET START WITH 600;
ALTER TABLE foo ALTER COLUMN gid SET INCREMENT BY 3 RESTART 1000;
ALTER TABLE foo ALTER COLUMN gid RESTART 1000;
ALTER TABLE foo ALTER COLUMN gid SET START WITH 1000;
ALTER TABLE foo ALTER COLUMN gid SET INCREMENT BY 3;
```

* En los casos de uso de iCarto es habitual generar datos que deben ser insertados en _bulk_ en producción. Y encontramos valor en setear el valor de la clave primaria a mano por varios motivos (por ejemplo pre-establecer relaciones entre varias tablas, orden por defecto, ...). Por ello usamos [`BY DEFAULT` y no `ALWAYS`](http://www.postgresqltutorial.com/postgresql-identity-column/).


### Migración

El "implementador" de las Identity Columns provee de [una función de migración en el blog de 2quadrant](https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns/) para migrar una columna determinada.

Para detectar las secuencias asociadas a tablas o pre-generar las llamadas a la función nos podemos basar en este código:

```sql
SELECT
    n.nspname as schema_name
    , t.relname as related_table
    , a.attname as related_column
    , s.relname as sequence_name
    , r.rolname as owner_name, deptype
FROM
    pg_class s
    JOIN pg_depend d ON d.objid = s.oid
    JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid
    JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum)
    JOIN pg_namespace n ON n.oid = s.relnamespace
    JOIN pg_catalog.pg_roles r ON r.oid = t.relowner
WHERE s.relkind = 'S' AND deptype = 'a'
ORDER BY 1, 2, 3, 4;

\pset border 0

SELECT
    format('SELECT upgrade_serial_to_identity(%L, %L);', n.nspname || '.' || t.relname, a.attname)
FROM
    pg_class s
    JOIN pg_depend d ON d.objid = s.oid
    JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid
    JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum)
    JOIN pg_namespace n ON n.oid = s.relnamespace
    JOIN pg_catalog.pg_roles r ON r.oid = t.relowner
WHERE s.relkind = 'S' AND deptype = 'a'
ORDER BY 1;
```


## Serial Columns

Las declaramos así

```sql
CREATE TABLE public.mytable (
    gid SERIAL PRIMARY KEY
    , foo TEXT
);

REVOKE ALL ON public.mytable FROM PUBLIC; -- Es mejor ser explícitos
REVOKE ALL ON SEQUENCE public.my_gid_seq FROM PUBLIC;

GRANT SELECT, INSERT, UPDATE, DELETE ON public.mytable TO role_edit;
GRANT USAGE ON SEQUENCE public.my_gid_seq TO role_edit;

GRANT SELECT ON public.mytable TO role_view;
```

## Curiosidades y otras observaciones

* En general la diferencia entre usar un integer como _surrogate key_, frente a un string como _natural key_ no tiene mejoras de rendimiento, si no más bien posibles penalizaciones. Pero en general no son significativas. [1](https://www.depesz.com/2012/06/07/123-vs-depesz-what-is-faster/). [2](https://www.depesz.com/2012/06/08/123%E2%80%B3-vs-depesz-followup/)


## Referencias

* [Información básica sobre SERIAL](http://www.postgresqltutorial.com/postgresql-serial/)
* [Porqué UUID suele ser mejor idea que AutoIncremental](https://www.clever-cloud.com/blog/engineering/2015/05/20/why-auto-increment-is-a-terrible-idea/)
* [Más sobre Identity](https://programmer.group/new-feature-of-postgresql-10-identity-column-serial-self-increasing.html)
* https://www.postgresql.org/docs/current/sql-createtable.html
* https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL



## Investigaciones y mejoras futuras

Para empezar a usar [_natural keys_ en lugar de _surrogate keys_](https://tapoueh.org/blog/2018/03/database-normalization-and-primary-keys/) debemos conocer el comportamiento de distintas aplicaciones y versiones de aplicaciones GIS de escritorio que estén entre nuestro target con:

* El uso de <a href="http://blog.joevandyk.com/2013/08/14/uuids-as-keys/">UUID</a>
* Claves primarias de múltiples columnas
* Claves primarias no numéricas
* Si existe valor en conocer un supuesto orden de inserción (o controlarlo de algún modo) usando el SERIAL, o es mejor relegar en `created_at` o similares.
